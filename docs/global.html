<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Global - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="wait.html">wait</a><ul class='methods'><li data-type='method'><a href="wait.html#.json">json</a></li><li data-type='method'><a href="wait.html#.obj">obj</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#drop">drop</a></li><li><a href="global.html#filter">filter</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#findWhere">findWhere</a></li><li><a href="global.html#intersperse">intersperse</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#pick">pick</a></li><li><a href="global.html#pipeline">pipeline</a></li><li><a href="global.html#pluck">pluck</a></li><li><a href="global.html#reduce">reduce</a></li><li><a href="global.html#sort">sort</a></li><li><a href="global.html#split">split</a></li><li><a href="global.html#stringify">stringify</a></li><li><a href="global.html#take">take</a></li><li><a href="global.html#through">through</a></li><li><a href="global.html#where">where</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Global</h1>
    

    




<section>

<header>
    
        <h2>
        
        </h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        

        


<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>


        
    
    </div>

    

    

    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id="drop"><span class="type-signature"></span>drop<span class="signature">(n)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new Stream without the first `n` values from the source stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>n</code></td>
            

            <td class="type">
            
                
<span class="param-type">Number</span>


            
            </td>

            

            

            <td class="description last">Number of items to drop from the source stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.4.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_drop.js.html">modifiers/drop.js</a>, <a href="modifiers_drop.js.html#line23">line 23</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// drop the first 3 items from a stream
inStream // => ['b', 'a', 'n', 'a', 'n', 'a']
  .pipe(nodeStream.drop(3))
  .pipe(process.stdout)
  // => ['a', 'n', 'a']</code></pre>



        
            

    

    <h4 class="name" id="filter"><span class="type-signature"></span>filter<span class="signature">(condition)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream with all elements that pass the test implemented by the
provided function. Similar to Array.filter... but on a stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>condition</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">Function that filters elements on the stream.
                                 Takes one argument, the value of the item at
                                 this position in the stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.0.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_filter.js.html">modifiers/filter.js</a>, <a href="modifiers_filter.js.html#line67">line 67</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - A transform stream with the filtered values.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// If you wanted to create a new stream whose values all passed a certain criteria,
// you could do something like the following. Assuming "test-scores.txt" is a file
// containing the following data:
// Sally...90
// Tommy...94
// Jimmy...12
// Sarah...82
// Jonny...64

// We can write a function that returns the students who are failing:
fs.createReadStream('test-scores.txt')
  .pipe(nodeStream.split()) // split on new lines
  .pipe(nodeStream.filter(value => {
    const [student, testScore] = value.toString().split('...');

    return Number(testScore) &lt; 70;
  }));

// The resulting stream would have the following data:
// Jimmy...12
// Jonny...64


// It is also possible to filter a stream asynchronously for more complex actions.
// Note: The signature of the function that you pass as the callback is important. It
// MUST have *two* parameters.

// Assuming "filenames.txt" is a newline-separated list of file names, you could
// create a new stream with only valid names by doing something like the following:
fs.createReadStream('filenames.txt')
  .pipe(nodeStream.split()) // split on new lines
  .pipe(nodeStream.filter((value, next) => {
    fs.stat(value, (err, stats) => {

      // Error the stream since this file is not valid
      if (err) {
        return next(err);
      }

      next(null, stats.isFile());
    });
  }));

// The resulting stream will contain the filenames that passed the test. Note: If `next`
// is called with an error as the first argument, the stream will error. This is typical
// behavior for node callbacks.</code></pre>



        
            

    

    <h4 class="name" id="find"><span class="type-signature"></span>find<span class="signature">(condition)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new Stream with the first element from the source stream
where `condition` is true. A convenient form of `filter`.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>condition</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">Function that filters elements on the stream.
                                 Takes one argument, the value of the item at
                                 this position in the stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.4.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_find.js.html">modifiers/find.js</a>, <a href="modifiers_find.js.html#line67">line 67</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - A transform stream with the first value that
                                 passed the test.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// If you wanted to create a new stream with the first value that passed a certain
// criteria, you could do something like the following. Assuming "test-scores.txt"
// is a file containing the following data:
// Sally...90
// Tommy...94
// Jimmy...12
// Sarah...82
// Jonny...64

// We can write a function that returns the first failing student:
fs.createReadStream('test-scores.txt')
  .pipe(nodeStream.split()) // split on new lines
  .pipe(nodeStream.find(value => {
    const [student, testScore] = value.toString().split('...');

    return Number(testScore) &lt; 70;
  }));

// The resulting stream would have the following data:
// Jimmy...12


// It is also possible to filter a stream asynchronously for more complex actions.
// Note: The signature of the function that you pass as the callback is important. It
// MUST have *two* parameters.

// Assuming "filenames.txt" is a newline-separated list of file names, you could
// create a new stream with the first valid filename by doing something like the following:
fs.createReadStream('filenames.txt')
  .pipe(nodeStream.split()) // split on new lines
  .pipe(nodeStream.find((value, next) => {
    fs.stat(value, (err, stats) => {

      // Error the stream since this file is not valid
      if (err) {
        return next(err);
      }

      next(null, stats.isFile());
    });
  }));

// The resulting stream will contain the first filename that passed the test. Note: If `next`
// is called with an error as the first argument, the stream will error. This is typical
// behavior for node callbacks.</code></pre>



        
            

    

    <h4 class="name" id="findWhere"><span class="type-signature"></span>findWhere<span class="signature">(query)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new Stream with the first element from the source stream
that matches the `query`. A convenient form of `where`. It performs
a deep comparison between a given `query` and items in the source
stream. Items that match the `query` are forwarded to the output
stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>query</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>


            
            </td>

            

            

            <td class="description last">An object of properties to compare against all items in
                           the source stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.4.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_findWhere.js.html">modifiers/findWhere.js</a>, <a href="modifiers_findWhere.js.html#line27">line 27</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// find the first element that matches the condition
objStream // => [{ name: 'Bob', age: 30 }, { name: 'Lisa', age: 30 }]
  .pipe(nodeStream.findWhere({ age: 30 })
  // => [{ name: 'Bob', age: 30 }]</code></pre>



        
            

    

    <h4 class="name" id="intersperse"><span class="type-signature"></span>intersperse<span class="signature">(value)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream with the `value` emitted between every item in the source
stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">String</span>


            
            </td>

            

            

            <td class="description last">Value that should be emitted between every existing item.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.3.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_intersperse.js.html">modifiers/intersperse.js</a>, <a href="modifiers_intersperse.js.html#line22">line 22</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// Log some values to the console with new lines interspersed
shoppingList // => ['banana', 'apple', 'orange']
  .pipe(nodeStream.intersperse('\n'))
  .pipe(process.stdout)
  // => ['banana', '\n', 'apple', '\n', 'orange']</code></pre>



        
            

    

    <h4 class="name" id="map"><span class="type-signature"></span>map<span class="signature">(transform)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream with the results of calling the provided function on
every item in the stream. Similar to Array.map... but on a stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>transform</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">Function that returns a new element on the
                                 stream. Takes one argument, the value of the
                                 item at this position in the stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.0.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_map.js.html">modifiers/map.js</a>, <a href="modifiers_map.js.html#line45">line 45</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - A transform stream with the modified values.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// For a simple find/replace, you could do something like the following. Assuming
// "example.txt" is a file with the text "the text has periods. because, english.",
// you could replace each period with a comma like so:
fs.createReadStream('example.txt')
  .pipe(nodeStream.map(value => value.toString().replace('.', ',')));

// The resulting stream will have the value "the text has periods, because, english,".


// It is also possible to transform a stream asynchronously for more complex actions.
// Note: The signature of the function that you pass as the callback is important. It
// MUST have *two* parameters.

// Assuming "filenames.txt" is a newline-separated list of file names, you could
// create a new stream with their contents by doing something like the following:
fs.createReadStream('filenames.txt')
  .pipe(nodeStream.split()) // split on new lines
  .pipe(nodeStream.map((value, next) => {
    fs.readFile(value, next);
  }));

// The resulting stream will contain the text of each file. Note: If `next` is called
// with an error as the first argument, the stream will error. This is typical behavior
// for node callbacks.</code></pre>



        
            

    

    <h4 class="name" id="parse"><span class="type-signature"></span>parse<span class="signature">(options<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream where every element in the source stream
is parsed as JSON.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>options</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Options to use when parsing items in the stream.
                <h6>Properties</h6>
                

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>error</code></td>
            

            <td class="type">
            
                
<span class="param-type">Boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    true
                
                </td>
            

            <td class="description last">If true, an error caught when parsing JSON
                                             will be emitted on the stream. If false, the
                                             unparseable item will be removed from the stream
                                             without error.</td>
        </tr>

    
    </tbody>
</table>

            </td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.1.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_parse.js.html">modifiers/parse.js</a>, <a href="modifiers_parse.js.html#line33">line 33</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// parse a newline-separated JSON file
fs.createReadStream('example.log')
  .pipe(nodeStream.split())
  .pipe(nodeStream.parse());


// parse a large JSON file
fs.createReadStream('warandpeace.json')
  .pipe(nodeStream.wait())
  .pipe(nodeStream.parse());</code></pre>



        
            

    

    <h4 class="name" id="pick"><span class="type-signature"></span>pick<span class="signature">(&hellip;properties)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream with the output composed of the picked properties from the source stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>properties</code></td>
            

            <td class="type">
            
                
<span class="param-type">String</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last">A collection of properties that will
                                   be picked from the source object.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.3.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_pick.js.html">modifiers/pick.js</a>, <a href="modifiers_pick.js.html#line24">line 24</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// get some properties from each item in the stream
// (e.g.: [{ name: 'pam', age: 24 }, { name: 'joe', age: 30 }])
objStream
  .pipe(nodeStream.pick('age'))
  // => [{ age: 24 }, { age: 30 }]</code></pre>



        
            

    

    <h4 class="name" id="pipeline"><span class="type-signature"></span>pipeline<span class="signature">(&hellip;streams)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Returns a new stream that writes to the first given stream and reads from
the last given stream. All errors are routed to the new output stream. This is a
wrapper of <a href="https://www.npmjs.com/package/stream-combiner2">stream-combiner2</a>
by <a href="https://github.com/substack">substack</a>.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>streams</code></td>
            

            <td class="type">
            
                
<span class="param-type">Stream</span>
|

<span class="param-type">Array.&lt;Stream></span>


            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last">A series of streams that will be combined
                                          into a single output stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.0.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_pipeline.js.html">modifiers/pipeline.js</a>, <a href="modifiers_pipeline.js.html#line39">line 39</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// emit the largest line in a file
function getLargestLine() {
  return nodeStream.pipeline(
    nodeStream.split(),
    nodeStream.sort((a, b) => {
      return a.length &lt; b.length;
    }),
    nodeStream.take(1)
  );
}

// find the longest line of a haiku
process.stdin // => ['refreshing and cool\nlove is ', 'a sweet summer ', 'rain\nthat washes the world']
  .pipe(getLargestLine())
  // => ['love is a sweet summer rain']</code></pre>



        
            

    

    <h4 class="name" id="pluck"><span class="type-signature"></span>pluck<span class="signature">(property)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream with the output composed of the plucked property
from each item in the source stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>property</code></td>
            

            <td class="type">
            
                
<span class="param-type">String</span>
|

<span class="param-type">Number</span>


            
            </td>

            

            

            <td class="description last">A property name that will be plucked from
                                     each item in the source stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.3.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_pluck.js.html">modifiers/pluck.js</a>, <a href="modifiers_pluck.js.html#line24">line 24</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// get the value of the "age" property for every item in the stream
objStream // => [{ name: 'pam', age: 24 }, { name: 'joe', age: 30 }])
  .pipe(nodeStream.pluck('age'))
  // => [24, 30]</code></pre>



        
            

    

    <h4 class="name" id="reduce"><span class="type-signature"></span>reduce<span class="signature">(reducer, initialValue<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream with a single item that's produced by calling a reducer with
each item of the original stream. Similar to Array.reduce... but on a stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Function that reduces items in the stream. Takes
                                      two arguments: the current value of the reduction,
                                      and the value of the item at this position in the
                                      stream.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>initialValue</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Value to use as the first argument to the first
                                      call of the `reducer`.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.0.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_reduce.js.html">modifiers/reduce.js</a>, <a href="modifiers_reduce.js.html#line67">line 67</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - A transform stream that results from the reduction.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// If you wanted to determine the content-length of a stream, you could do something like
// the following. Assuming "example.txt" is a large file, you could determine it's length
// by doing the following:
fs.createReadStream('example.txt')
  .pipe(nodeStream.reduce((length, value) => length + value.length), 0);

// The resulting stream will have an integer value representing the length of "example.txt".


// It is also possible to reduce a stream asynchronously for more complex actions.
// Note: The signature of the function that you pass as the callback is important. It
// MUST have *three* parameters.

// Assuming "twitterers.txt" is a newline-separated list of your favorite tweeters, you
// could identify which is the most recently active by using the Twitter API:
fs.createReadStream('twitterers.txt')
  .pipe(nodeStream.split()) // split on new lines
  .pipe(nodeStream.reduce((memo, user, next) => {
    twit.get('search/tweets', { q: `from:${user}`, count: 1 }, (err, data) => {

      // Error the stream since this request failed
      if (err) {
        return next(err);
      }

      // This is the first iteration of the reduction, so we automatically save the tweet
      if (!memo) {
        return next(null, data);
      }

      // This tweet is the most recent so far, save it for later
      if (new Date(data.statuses.created_at) > new Date(memo.statuses.created_at)) {
        return next(null, data);
      }

      // The tweet we have saved is still the most recent
      next(null, memo);
    });
  }));

// The resulting stream will contain the most recent tweet of the users in the list.
// Note: If `next` is called with an error as the first argument, the stream will error.
// This is typical behavior for node callbacks.</code></pre>



        
            

    

    <h4 class="name" id="sort"><span class="type-signature"></span>sort<span class="signature">(compareFunction)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream where all elements of the source stream have been
sorted by the Array.sort method. Each value will be emitted individually.

*Note:* This method will buffer all contents of the source stream before
sending it. You should not use this method if your source stream is large
as it could consume large amounts of memory.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>compareFunction</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">A function that will be passed directly
                                       to Array.sort for item comparison.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.3.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_sort.js.html">modifiers/sort.js</a>, <a href="modifiers_sort.js.html#line31">line 31</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// sort a stream of numbers
objStream // => [10, 3, 9, 2, 4, 1]
  .pipe(nodeStream.sort())
  // => [1, 2, 3, 4, 9, 10]</code></pre>



        
            

    

    <h4 class="name" id="split"><span class="type-signature"></span>split<span class="signature">(matcher<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Returns a stream that has been split on new lines (by default). This is a
wrapper of <a href="https://www.npmjs.com/package/split2">split2</a> by
<a href="https://github.com/mcollina">mcollina</a>.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>matcher</code></td>
            

            <td class="type">
            
                
<span class="param-type">RegExp</span>
|

<span class="param-type">String</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">A regular expression or string to split
                                     the stream by. The characters that match
                                     this regular expression are removed.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.0.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line69">line 69</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="stringify"><span class="type-signature"></span>stringify<span class="signature">()</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new stream where every element in the source stream
is converted to a string by using `JSON.stringify`.
</div>













<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.1.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_stringify.js.html">modifiers/stringify.js</a>, <a href="modifiers_stringify.js.html#line21">line 21</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// stringify every element in an object stream so it can be
// piped to a non-object stream.
objStream
  .pipe(nodeStream.stringify())
  .pipe(process.stdout);</code></pre>



        
            

    

    <h4 class="name" id="take"><span class="type-signature"></span>take<span class="signature">(n)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Creates a new Stream with the first `n` values from the source stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>n</code></td>
            

            <td class="type">
            
                
<span class="param-type">Number</span>


            
            </td>

            

            

            <td class="description last">Number of items to take from the source stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.4.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_take.js.html">modifiers/take.js</a>, <a href="modifiers_take.js.html#line23">line 23</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// take the first 3 items from a stream
inStream // => ['b', 'a', 'n', 'a', 'n', 'a']
  .pipe(nodeStream.take(3))
  .pipe(process.stdout)
  // => ['b', 'a', 'n']</code></pre>



        
            

    

    <h4 class="name" id="through"><span class="type-signature"></span>through<span class="signature">(options<span class="signature-attributes">opt</span>, transform<span class="signature-attributes">opt</span>, flush<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    Returns a transform stream with a simple API. This is a wrapper of
<a href="https://www.npmjs.com/package/through2">through2</a> by
<a href="https://github.com/rvagg">rvagg</a>.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>options</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Optional and passed directly to `stream.Transform`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>transform</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">A function that takes a stream chunk, encoding and callback
                                  to transform the data in a stream. Additional items can
                                  be appended to the stream by calling `this.push(chunk)`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>flush</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">A function called at the end of the stream that can be
                                  used to finish up any processing. Additional items can be
                                  appended to the stream by calling `this.push(chunk)`.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.0.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line90">line 90</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="where"><span class="type-signature"></span>where<span class="signature">(query)</span><span class="type-signature"> &rarr; {Stream}</span></h4>

    



<div class="description">
    A convenient form of filter which performs a deep comparison between a given `query`
and items in the source stream. Items that match the `query` are forwarded to the output
stream.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>query</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>


            
            </td>

            

            

            <td class="description last">An object of properties to compare against all items in
                           the source stream.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    
    <dt class="tag-since">Since:</dt>
    <dd class="tag-since"><ul class="dummy"><li>1.3.0</li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="modifiers_where.js.html">modifiers/where.js</a>, <a href="modifiers_where.js.html#line25">line 25</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    - Transform stream.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Stream</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// Get all users from a given zip code
users // => [{ name: 'Bill', zip: 90210 }, { name: 'Tracy', zip: 33193 }, { name: 'Paul', zip: 90210 }]
  .pipe(nodeStream.where({ zip: 90210 }))
  // => [{ name: 'Bill', zip: 90210 }, { name: 'Paul', zip: 90210 }]</code></pre>



        
    

    

    
</article>

</section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Dec 21 2016 18:55:52 GMT-0500 (EST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>